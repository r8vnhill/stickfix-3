package cl.ravenhill.stickfix

import cl.ravenhill.jakt.constrainedTo
import cl.ravenhill.jakt.exceptions.CompositeException
import cl.ravenhill.stickfix.exceptions.QueryConstraintException
import io.kotest.assertions.throwables.shouldNotThrowAny
import io.kotest.assertions.throwables.shouldThrow
import io.kotest.common.ExperimentalKotest
import io.kotest.core.spec.style.FreeSpec
import io.kotest.matchers.collections.shouldHaveSize
import io.kotest.property.Arb
import io.kotest.property.PropTest
import io.kotest.property.PropTestConfig
import io.kotest.property.PropTestListener
import io.kotest.property.arbitrary.arbitrary
import io.kotest.property.arbitrary.filter
import io.kotest.property.arbitrary.int
import io.kotest.property.arbitrary.list
import io.kotest.property.checkAll
import org.jetbrains.exposed.dao.id.IntIdTable
import org.jetbrains.exposed.sql.Database
import org.jetbrains.exposed.sql.SchemaUtils
import org.jetbrains.exposed.sql.insert
import org.jetbrains.exposed.sql.selectAll
import org.jetbrains.exposed.sql.transactions.transaction

@OptIn(ExperimentalKotest::class)
class HaveSizeTest : FreeSpec({

    lateinit var database: Database

    beforeEach {
        database = Database.connect("jdbc:h2:mem:test;DB_CLOSE_DELAY=-1;", "org.h2.Driver")
        transaction(database) {
            SchemaUtils.create(TestTable)
        }
    }

    afterEach {
        transaction(database) {
            SchemaUtils.drop(TestTable)
        }
    }

    "A HaveSize constraint" - {
        "should pass when the query result size matches the expected size" {
            checkAll(
                PropTestConfig(listeners = listOf(ResetTableListener(database))),
                arbInitTableWithSize(database)
            ) { size ->
                shouldNotThrowAny {
                    transaction(database) {
                        TestTable.selectAll().constrainedTo { q ->
                            "Query result must have size $size" {
                                q must HaveSize {
                                    it == size.toLong()
                                }
                            }
                        }
                    }
                }
            }
        }

        "should fail when the query result size does not match the expected size" {
            checkAll(
                PropTestConfig(listeners = listOf(ResetTableListener(database))),
                arbInitTableWithDifferentSize(database)
            ) { size ->
                val exception = shouldThrow<CompositeException> {
                    transaction(database) {
                        TestTable.selectAll().constrainedTo { q ->
                            "Query result must have size $size" {
                                q must HaveSize {
                                    it == size.toLong()
                                }
                            }
                        }
                    }
                }

                exception.throwables shouldHaveSize 1
                exception.throwables.filterIsInstance<QueryConstraintException>() shouldHaveSize 1
            }
        }
    }
})

/**
 * Generates an arbitrary size and populates the `TestTable` with a list of distinct integers. The size of the list
 * generated by this function is used as the expected size for the table contents.
 *
 * @param database The database instance where the `TestTable` resides.
 * @return An `Arb<Int>` that provides the size of the list inserted into the `TestTable`.
 */
private fun arbInitTableWithSize(database: Database) = arbitrary {
    // Generate a list of distinct integers with a size between 0 and 10
    val ints = Arb.list(Arb.int(), 0..10).filter { it.distinct().size == it.size }.bind()

    // Insert each integer into the `TestTable`
    transaction(database) {
        ints.forEach { i ->
            TestTable.insert {
                it[testColumn] = i
            }
        }
    }

    // Return the size of the inserted list
    ints.size
}

private fun arbInitTableWithDifferentSize(database: Database) = arbitrary {
    // Generate a list of distinct integers with a size between 0 and 10
    val ints = Arb.list(Arb.int(), 0..10).filter { it.distinct().size == it.size }.bind()

    // Insert each integer into the `TestTable`
    transaction(database) {
        ints.forEach { i ->
            TestTable.insert {
                it[testColumn] = i
            }
        }
    }

    // Return the size of the inserted list
    ints.size + Arb.int(-10..10).filter { it != 0 }.bind()
}

/**
 * Represents a table for testing purposes within the in-memory database. This table has a single column, `testColumn`,
 * which stores integer values.
 */
private object TestTable : IntIdTable() {
    val testColumn = integer("test_column")
}

/**
 * A listener that resets the `TestTable` before and after each test. This listener ensures that the table is
 * dropped and recreated, so each test starts with a clean table.
 *
 * @param database The database instance where the `TestTable` resides.
 */
private class ResetTableListener(private val database: Database) : PropTestListener {

    /**
     * Drops and recreates the `TestTable` after each test to ensure a clean state.
     */
    override suspend fun afterTest() {
        transaction(database) {
            SchemaUtils.drop(TestTable)
            SchemaUtils.create(TestTable)
        }
    }
}
